---
layout: post
title: uboot
categories: [uboot]
description: 
keywords: 
topmost: false
---

* TOC
{:toc}

[下载地址](https://ftp.denx.de/pub/u-boot/)

## Boot Loader

系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的Boot Loader程序。

Boot Loader (引导加载程序)就是在操作系统内核运行之前运行的一段小程序。通过这段代码
实现硬件的初始化，建立内存空间的映射，为操作系统内核准备好硬件环境并引导内核的启动。

Boot Loader的主要运行任务就是将内核镜像从硬盘(NAND flash or eMMC)上读到RAM中，然后跳转到内核的入口点去运行，即开始启动操作系统。Bootloader的启动过程可以分为单阶段(Single Stage)、多阶段(Multi-Stage)两种。

u-boot是一种通用的用于嵌入式系统的Bootloader，同时支持 ARM 体系结构和 MIPS 体系结构。uboot必须要具备的能力：

1. 能自身开机直接启动，必须进行和硬件相对应的代码级别的更改和移植，才能够保证可以从相应的启动介质启动。
2. 能引导操作系统内核启动并给内核传参，uboot 的终极目标就是启动内核，参数通过环境变量设置。
3. 能进行 SoC 级和板级硬件管理，控制部分硬件外设。
4. 能提供系统部署功能，实现flash上的烧录下载。

## 目录结构

![](/images/uboot/uboot_arch.png)

u-boot-2010.06及以后版本目录结构：

```t
├── api                存放uboot提供的接口函数
├── arch               CPU体系结构相关的代码，每种架构对应一个子目录
├── board              开发板相关的文件，每种开发板对应一个子目录
├── common             通用的代码，主要实现 uboot命令行下支持的命令，每一条命令对应一个文件。
├── disk               磁盘分区相关代码
├── doc                文档
├── drivers            支持的设备驱动
├── examples           示例程序
├── fs                 文件系统，目前支持 cramfs、fat、fdos、jffs2 和 registerfs
├── include            头文件，已通用的头文件为主
├── lib                通用库文件
├── nand_spl           NAND存储器相关代码
├── net                网络相关代码，小型的协议栈
├── onenand_ipl
├── post               加电自检程序
└── tools              辅助程序，用于编译和检查uboot目标文件
```

## 编译与配置

### Makefile 分析

```makefile
VERSION = 2013    #主版本号
PATCHLEVEL = 10   #次版本号
SUBLEVEL =        #子版本号
EXTRAVERSION =    #附加的版本信息
ifneq "$(SUBLEVEL)" ""
U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
else
U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL)$(EXTRAVERSION)
endif
TIMESTAMP_FILE = $(obj)include/generated/timestamp_autogenerated.h
VERSION_FILE = $(obj)include/generated/version_autogenerated.h

ifeq (,$(findstring s,$(MAKEFLAGS)))
XECHO = echo
else
XECHO = :
endif
```

uboot编译时，会将版本信息输出到 include\generated\version_autogenerated.h 文件中。`make -s` 可以使 XECHO 变量为空，关闭编译信息打印。

```makefile
MKCONFIG := $(SRCTREE)/mkconfig
export MKCONFIG

unconfig:
    @rm -f $(obj)include/config.h $(obj)include/config.mk \
        $(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \
        $(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep \
        $(obj)include/spl-autoconf.mk \
        $(obj)include/tpl-autoconf.mk
        
%_config:: unconfig
    @$(MKCONFIG) -A $(@:_config=)
```

设置[mkconfig](#mkconfig 分析)脚本的路径。

```makefile
all:
sinclude $(obj)include/autoconf.mk.dep
sinclude $(obj)include/autoconf.mk
```

导入include/autoconf.mk文件，由配置脚本根据inlcude/configs/xxx.h 头文件生成的，里面包含与开发板相关的配置。

```kconfig
CONFIG_SYS_TEXT_BASE=0x34800000
CONFIG_COMMON_BOOT=""console=ttySAC0,115200n8 mem=128M  " MTDPARTS_DEFAULT"
CONFIG_BOOTARGS=""root=/dev/mtdblock5 ubi.mtd=4 rootfstype=cramfs " CONFIG_COMMON_BOOT"
```

```makefile
include $(obj)include/config.mk
export ARCH CPU BOARD VENDOR SOC

include $(TOPDIR)/config.mk
```

导入include/config.mk文件，里面包含ARCH, BOARD, VENDOR, SOC 和 CPU 变量，这是配置过程自动生成的。

```makefile
ARCH   = arm
CPU    = armv7
BOARD  = smdkc100
VENDOR = samsung
SOC    = s5pc1xx
```

导入config.mk文件，里面定义编译工具配置项。

```makefile
CC = $(CROSS_COMPILE)gcc
CPP = $(CC) -E
AR = $(CROSS_COMPILE)ar
NM = $(CROSS_COMPILE)nm
LDR = $(CROSS_COMPILE)ldr
STRIP = $(CROSS_COMPILE)strip
OBJCOPY = $(CROSS_COMPILE)objcopy
OBJDUMP = $(CROSS_COMPILE)objdump
RANLIB = $(CROSS_COMPILE)RANLIB

LDFLAGS_u-boot += -T $(obj)u-boot.lds $(LDFLAGS_FINAL)
ifneq ($(CONFIG_SYS_TEXT_BASE),)
LDFLAGS_u-boot += -Ttext $(CONFIG_SYS_TEXT_BASE)
endif
```

`-Ttext`用 来指定uboot的链接起始地址，链接脚本也可以指定，但最终以这个为准。

```makefile
ifndef LDSCRIPT
    ifeq ($(CONFIG_NAND_U_BOOT),y)
        LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot-nand.lds
        ifeq ($(wildcard $(LDSCRIPT)),)
            LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot-nand.lds
        endif
    endif
    ifeq ($(wildcard $(LDSCRIPT)),)
        LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds
    endif
    ifeq ($(wildcard $(LDSCRIPT)),)
        LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot.lds
    endif
    ifeq ($(wildcard $(LDSCRIPT)),)
        LDSCRIPT := $(TOPDIR)/arch/$(ARCH)/cpu/u-boot.lds
        # We don't expect a Makefile here
        LDSCRIPT_MAKEFILE_DIR =
    endif
    ifeq ($(wildcard $(LDSCRIPT)),)
$(error could not find linker script)
    endif
endif
```

指定链接脚本，如果定义了 CONFIG_NAND_U_BOOT 宏，则链接脚本叫 u-boot-nand.lds，如果未定义这个宏则链接脚本叫 u-boot.lds。查找顺序为 board/, cpu_xxx/, arch/。

### mkconfig 分析

```shell
if [ \( $# -eq 2 \) -a \( "$1" = "-A" \) ] ; then
    # Automatic mode
    line=`awk '($0 !~ /^#/ && $7 ~ /^'"$2"'$/) { print $1, $2, $3, $4, $5, $6, $7, $8 }' boards.cfg`
    if [ -z "$line" ] ; then
        echo "make: *** No rule to make target \`$2_config'.  Stop." >&2
        exit 1
    fi

    set ${line}
    # add default board name if needed
    [ $# = 3 ] && set ${line} ${1}
fi
```

boards.cfg 文件定义了一张 board 与arch, cpu, soc, vendor 对应的表。通过解析 boards.cfg 文件可获得相应的信息。

```
Active  arm         armv7          s5pc1xx     samsung         smdkc100            smdkc100                                                
```

```shell
if [ "$SRCTREE" != "$OBJTREE" ] ; then
    mkdir -p ${OBJTREE}/include
    mkdir -p ${OBJTREE}/include2
    cd ${OBJTREE}/include2
    rm -f asm
    ln -s ${SRCTREE}/arch/${arch}/include/asm asm
    LNPREFIX=${SRCTREE}/arch/${arch}/include/asm/
    cd ../include
    mkdir -p asm
else
    cd ./include
    rm -f asm
    ln -s ../arch/${arch}/include/asm asm
fi

rm -f asm/arch

if [ -z "${soc}" ] ; then
    ln -s ${LNPREFIX}arch-${cpu} asm/arch
else
    ln -s ${LNPREFIX}arch-${soc} asm/arch
fi

if [ "${arch}" = "arm" ] ; then
    rm -f asm/proc
    ln -s ${LNPREFIX}proc-armv asm/proc
fi
```

创建 asm, arch, proc 3个指向具体平台的软连接。

```shell
( echo "ARCH   = ${arch}"
    if [ ! -z "$spl_cpu" ] ; then
    echo 'ifeq ($(CONFIG_SPL_BUILD),y)'
    echo "CPU    = ${spl_cpu}"
    echo "else"
    echo "CPU    = ${cpu}"
    echo "endif"
    else
    echo "CPU    = ${cpu}"
    fi
    echo "BOARD  = ${board}"

    [ "${vendor}" ] && echo "VENDOR = ${vendor}"
    [ "${soc}"    ] && echo "SOC    = ${soc}"
    exit 0 ) > config.mk
```

创建 include/config.mk 文件，被主 Makefile 包含。

```shell
echo "/* Automatically generated - do not edit */" >>config.h

for i in ${TARGETS} ; do
    i="`echo ${i} | sed '/=/ {s/=/	/;q; } ; { s/$/	1/; }'`"
    echo "#define CONFIG_${i}" >>config.h ;
done

echo "#define CONFIG_SYS_ARCH  \"${arch}\""  >> config.h
echo "#define CONFIG_SYS_CPU   \"${cpu}\""   >> config.h
echo "#define CONFIG_SYS_BOARD \"${board}\"" >> config.h

[ "${vendor}" ] && echo "#define CONFIG_SYS_VENDOR \"${vendor}\"" >> config.h

[ "${soc}"    ] && echo "#define CONFIG_SYS_SOC    \"${soc}\""    >> config.h

cat << EOF >> config.h
#define CONFIG_BOARDDIR board/$BOARDDIR
#include <config_cmd_defaults.h>
#include <config_defaults.h>
#include <configs/${CONFIG_NAME}.h>
#include <asm/config.h>
#include <config_fallbacks.h>
#include <config_uncmd_spl.h>
EOF
```

创建或追加(make -a) include/config.h 头文件，这个文件会被大部分c文件包含。

### u-boot.lds

arch/arm/cpu/u-boot.lds 是ld连接器的脚本文件，描述如何连接目标文件。

```asm
/* 指定输出可执行文件是 elf 格式,32 位 ARM 指令,小端 */
OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")

/* 指定输出可执行文件的平台架构为 ARM 架构 */
OUTPUT_ARCH(arm)

/* 指定程序的起始代码段为_start */
ENTRY(_start)

SECTIONS
{
    . = 0x00000000;  @ 指定程序的链接地址

    . = ALIGN(4);  @ 4字节对齐
    .text :
    {
        cpu/arm920t/start.o(.text)  @ 首先编译start.S
        *(.text)  @ 所有的其他程序的代码段以4字节对齐放在它后面
    }

    . = ALIGN(4);
    .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }

    . = ALIGN(4);
    .data : { *(.data) }

    . = ALIGN(4);
    .got : { *(.got) }

    . = .;
    __u_boot_cmd_start = .;  @ 把__u_boot_cmd_start赋值为当前位置，即起始位置
    .u_boot_cmd : { *(.u_boot_cmd) }  @ 指定 u_boot_cmd段，把所有的uboot命令放在该段
    __u_boot_cmd_end = .;  @ 把 __u_boot_cmd_end赋值为当前位置，即结束位置

    . = ALIGN(4);
    __bss_start = .;
    .bss (NOLOAD) : { *(.bss) . = ALIGN(4); }
    _end = .;
}
```

由.text段的编译顺序可知，uboot 首先运行的是 _start 符号处的代码，在 arch/arm/cpu/arm920t/[start.S](#start.S) 文件中定义。

## 启动流程分析

第一阶段(stage 1)依赖于 CPU 体系结构的代码，在 SRAM 中，一般用汇编语言来实现。主要进行以下方面的设置：设置 ARM 进入 SVC 模式、禁止 IRQ 和 FIQ、关闭看门狗、屏蔽所有中断。设置CPU的速度和时钟(FCLK,HCLK,PCLK)，RAM初始化，清空 I/D cache、清空 TLB、禁止 MMU 和 cache、配置内存控制器、为搬运代码做准备、搬移 uboot 镜像到 RAM 中（使用 copy_loop 实现）、分配堆栈、清空 bss 段（使用 clbss_l 实现）。最后跳转到第二阶段。

主要功能为：
- 硬件设备初始化。
- 为加载第二阶段代码准备RAM空间。
- 拷贝第二阶段代码到 RAM 空间中。
- 设置好栈。
- 跳转到第二阶段代码的C入口点。

第二阶段(stage 2)在 DRAM 中，用c语言来实现，这样可以实现更复杂的功能，而且代码会具有更好的可读性和可移植性。初始化SoC 外部硬件(如 iNand、网卡芯片等)、 uboot 本身的一些东西(uboot 的命令、环境变量等)。

主要功能为：

- 初始化本阶段要使用到的硬件设备。
- 检测系统内存映射(memory map)。
- 将内核镜像和根文件系统镜像从Flash上读到RAM空间中。
- 为内核设置启动参数。
- 调用内核。

### start.S

#### 设置异常向量表

```asm
.globl _start                        /* u-boot 启动入口 */
_start: b reset                    /* 复位 */
    ldr pc, _undefined_instruction   /* 未定义指令向量 */
    ldr pc, _software_interrupt      /* 软件中断向量 */
    ldr pc, _prefetch_abort          /* 预取指令异常向量 */
    ldr pc, _data_abort              /* 数据操作异常向量 */
    ldr pc, _not_used                /* 未使用 */
    ldr pc, _irq                     /* irq 中断向量 */            
    ldr pc, _fiq                     /* fiq 中断向量 */

/* 中断向量表入口地址 */
_undefined_instruction: .word undefined_instruction
_software_interrupt:    .word software_interrupt
_prefetch_abort:    .word prefetch_abort
_data_abort:        .word data_abort
_not_used:      .word not_used
_irq:           .word irq
_fiq:           .word fiq

    .balignl 16,0xdeadbeef
```
异常向量表是硬件决定的，软件只是参照硬件的设计来实现它。复位异常处的代码是`b reset`，因此在 CPU 复位后真正去执行的是[ reset ](#reset复位)符号处代码。

`.balignl 16,0xdeadbeef`指令是让当前地址对齐排布，如果当前地址不对齐则后面的内存用 0xdeadbeef 来填充。

uboot编译好之后，在 uboot 目录下会生成个 System.map 文件，这里面有各个变量的值。

```
c3e00010 T _start
c3e00030 t _undefined_instruction
c3e00034 t _software_interrupt
c3e00038 t _prefetch_abort
c3e0003c t _data_abort
c3e00040 t _not_used
c3e00044 t _irq
c3e00048 t _fiq
c3e0004c t _pad
```

#### 指定代码段的编译地址

```asm
.globl _TEXT_BASE
_TEXT_BASE:
#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_TEXT_BASE)
    .word   CONFIG_SPL_TEXT_BASE
#else
    .word   CONFIG_SYS_TEXT_BASE
#endif
```

编译器会对每一条指令分配一个编译地址，是编译器在编译过程中分配的。运行地址是指程序指令真正运行的地址，是由用户指定的。编译地址与运行地址是一一对应的。

#### reset复位

```asm
.globl	reset
reset:
    bl	save_boot_params
    /*
     * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
     * except if in HYP mode already
     */
    mrs	r0, cpsr
    and	r1, r0, #0x1f		@ mask mode bits
    teq	r1, #0x1a		@ test for HYP mode
    bicne	r0, r0, #0x1f		@ clear all mode bits
    orrne	r0, r0, #0x13		@ set SVC mode
    orr	r0, r0, #0xc0		@ disable FIQ and IRQ
    msr	cpsr,r0

#ifndef CONFIG_SKIP_LOWLEVEL_INIT
    bl	cpu_init_cp15
    bl	cpu_init_crit
#endif

    bl	_main
    
ENTRY(save_boot_params)
    bx	lr			@ back to my caller
ENDPROC(save_boot_params)
    .weak	save_boot_params
```
cpu设置为 SVC 模式，屏蔽 IRQ 和 FIQ 中断。跳转到[cpu_init_cp15](#cp15 协处理器初始化)处初始化协处理器。

```asm
ENTRY(cpu_init_crit)
    b	lowlevel_init		@ go setup pll,mux,memory
ENDPROC(cpu_init_crit)
```
cpu_init_crit 实现cpu核心初始化，主要由 lowlevel_init 完成，代码位于 board 目录下相应 [lowlevel_init.S ](#lowlevel_init.S)文件中。

复位成功后程序跳转到_main符号处执行，代码位于arch/arm/lib/目录下的 [crt0.S](#crt0.S) 文件中。

#### cp15 协处理器初始化

关闭MMU和cache。catch 是 cpu 内部的一个 2 级缓存，,她的作用是将常用的数据和指令放在 cpu 内部，关闭catch可使volatile无效，避免编译器对代码进行优化。uboot设置的寄存器都是物理地址，不需要虚拟地址，所以MMU可以关闭。

设置 TTB。TTB 就是 translation table base，转换表基地址。建立虚拟地址映射的主要工作就是建立这张转换表。转换表分为表索引和表项，表索引对应虚拟地址，表项对应物理地址。一对表索引和表项构成一个转换表单元，能够对一个内存块进行虚拟地址转换。转换表由若干个转换表单元构成的，每个单元负责 1 个内存块，总体的转换表负责整个内存空间的映射。

转换表放置在内存中，放置时要求起始地址在内存中要 x 位对齐。转换表不需要软件干涉，将基地址 TTB 设置到 cp15 的 c2 寄存器中，然后 MMU 工作时会自动去查转换表。

#### 复制 stage2 到 RAM

拷贝 stage2 到 RAM时要确定两点：
-　stage2 的可执行镜像在固态存储设备的存放起始地址和终止地址；
-　RAM 空间的起始地址；

```asm
    ldr	r0, =_start
    ldr	r1, =0x0
    mov	r2, #16
copyex:
    subs	r2, r2, #1
    ldr	r3, [r0], #4
    str	r3, [r1], #4
    bne	copyex
```

#### 设置堆栈

将 sp 指针指向一段没有被使用的内存就完成栈的设置。
![1590311696418](/images/uboot/uboot_mem.png)

#### 清除 BSS 段

BSS 段存放初始值为 0，未初始化的全局变量和静态变量，应该将这些变量的初始值赋为 0。

#### 跳转到 stage2 入口

### lowlevel_init.S

lowlevel_init 做一些开发板的初始化：检查复位状态、IO恢复、关看门狗、开发板供电锁存、时钟初始化、DDR初始化、串口初始化并打印’O’、tzpc初始化打印’K’。

### crt0.S

```asm
ENTRY(_main)
#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
    ldr	sp, =(CONFIG_SPL_STACK)
#else
    ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
#endif
    bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */
    sub	sp, #GD_SIZE	/* allocate one GD above SP */
    bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */
    mov	r9, sp		/* GD is above SP */
    mov	r0, #0
    bl	board_init_f
```

设置sp栈指针，将栈地址8位对齐。sp减去全局变量的长度，就是给全局数据分配空间，再把sp的值传给r9，就是把gd全局变量放在r9寄存器中。栈空间紧靠在dg全局变量之上，然后调用 [board_init_f](#board_init_f)函数。这个环境只有代码段，所以不包含变量，只包含只读常量。

```asm
#if !defined(CONFIG_SPL_BUILD)
    ldr	sp, [r9, #GD_START_ADDR_SP]	/* sp = gd->start_addr_sp */
    bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */
    ldr	r9, [r9, #GD_BD]		/* r9 = gd->bd */
    sub	r9, r9, #GD_SIZE		/* new GD is below bd */

    adr	lr, here
    ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd->reloc_off */
    add	lr, lr, r0
    ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd->relocaddr */
    b	relocate_code
here:
```
调用[relocate_code](#relocate_code)重新定位uboot，对于SPL，不用重新定位。relocate_code 函数在 arch/arm/lib/
relocate.S 文件中定义。


```asm
    bl	c_runtime_cpu_setup	/* we still call old routine here */

    ldr	r0, =__bss_start	/* this is auto-relocated! */
    ldr	r1, =__bss_end		/* this is auto-relocated! */

    mov	r2, #0x00000000		/* prepare zero to clear BSS */

clbss_l:cmp	r0, r1			/* while not at end of BSS */
    strlo	r2, [r0]		/* clear 32-bit BSS word */
    addlo	r0, r0, #4		/* move to next */
    blo	clbss_l

    bl coloured_LED_init
    bl red_led_on

    /* call board_init_r(gd_t *id, ulong dest_addr) */
    mov     r0, r9                  /* gd_t */
    ldr	r1, [r9, #GD_RELOCADDR]	/* dest_addr */
    /* call board_init_r */
    ldr	pc, =board_init_r	/* this is auto-relocated! */

ENDPROC(_main)
```
调用[board_init_r](#board_init_r)函数，这个环境包含BSS段和.data段。

### gd全局变量

```c
#include <asm-generic/global_data.h>

#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r9")  //放到寄存器r9中


#ifndef __ASSEMBLY__
typedef struct global_data {
    bd_t *bd;
    unsigned long flags;
    unsigned int baudrate;
    unsigned long cpu_clk;	/* CPU clock in Hz!		*/
    unsigned long bus_clk;
    /* We cannot bracket this with CONFIG_PCI due to mpc5xxx */
    unsigned long pci_clk;
    unsigned long mem_clk;
#if defined(CONFIG_LCD) || defined(CONFIG_VIDEO)
    unsigned long fb_base;	/* Base address of framebuffer mem */
#endif
#if defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)
    unsigned long post_log_word;  /* Record POST activities */
    unsigned long post_log_res; /* success of POST test */
    unsigned long post_init_f_time;  /* When post_init_f started */
#endif
#ifdef CONFIG_BOARD_TYPES
    unsigned long board_type;
#endif
    unsigned long have_console;	/* serial_init() was called */
#ifdef CONFIG_PRE_CONSOLE_BUFFER
    unsigned long precon_buf_idx;	/* Pre-Console buffer index */
#endif
#ifdef CONFIG_MODEM_SUPPORT
    unsigned long do_mdm_init;
    unsigned long be_quiet;
#endif
    unsigned long env_addr;	/* Address  of Environment struct */
    unsigned long env_valid;	/* Checksum of Environment valid? */

    unsigned long ram_top;	/* Top address of RAM used by U-Boot */

    unsigned long relocaddr;	/* Start address of U-Boot in RAM */
    phys_size_t ram_size;	/* RAM size */
    unsigned long mon_len;	/* monitor len */
    unsigned long irq_sp;		/* irq stack pointer */
    unsigned long start_addr_sp;	/* start_addr_stackpointer */
    unsigned long reloc_off;
    struct global_data *new_gd;	/* relocated global data */
    const void *fdt_blob;	/* Our device tree, NULL if none */
    void *new_fdt;		/* Relocated FDT */
    unsigned long fdt_size;	/* Space reserved for relocated FDT */
    void **jt;		/* jump table */
    char env_buf[32];	/* buffer for getenv() before reloc. */
#ifdef CONFIG_TRACE
    void		*trace_buff;	/* The trace buffer */
#endif
#if defined(CONFIG_SYS_I2C)
    int		cur_i2c_bus;	/* current used i2c bus */
#endif
    struct arch_global_data arch;	/* architecture-specific data */
} gd_t;
```

gd 是一个指向gd_t类型的全局变量指针，地址是r9寄存器。

```c
#ifndef __ASSEMBLY__
typedef struct bd_info {
    unsigned int	bi_baudrate;	/* serial console baudrate */
    ulong	        bi_arch_number;	/* unique id for this board */
    ulong	        bi_boot_params;	/* 向kernel传参的内存地址 */
    unsigned long	bi_arm_freq; /* arm frequency */
    unsigned long	bi_dsp_freq; /* dsp core frequency */
    unsigned long	bi_ddr_freq; /* ddr frequency */
    struct				/* RAM configuration */
    {
    ulong start;
    ulong size;
    }			bi_dram[CONFIG_NR_DRAM_BANKS];
} bd_t;
#endif
```

bd_t 是开发板的板级信息的结构体， 包含硬件相关的参数，如波特率、IP 地址、机器码、DDR 内存分布。

- bi_arch_number 是开发板的机器码。就是 uboot 给这个开发板定义的一个唯一编号，主要作用是在 uboot 和 linux 内核之间进行比对和适配。

- bi_boot_params  表示uboot给linux内核传参的内存地址，bootargs参数就是放在这里。


### board_init_f

uboot 第二阶段代码的入口是 board_init_f 函数，是第一个在内存中运行的代码，在 arch/arm/lib/board.c 中定义。
```c
void board_init_f(ulong bootflag)
{
    bd_t *bd;
    init_fnc_t **init_fnc_ptr;
    gd_t *id;
    ulong addr, addr_sp;
#ifdef CONFIG_PRAM
    ulong reg;
#endif
    void *new_fdt = NULL;
    size_t fdt_size = 0;

    memset((void *)gd, 0, sizeof(gd_t));

    gd->mon_len = _bss_end_ofs;
#ifdef CONFIG_OF_EMBED
    /* Get a pointer to the FDT */
    gd->fdt_blob = _binary_dt_dtb_start;
#elif defined CONFIG_OF_SEPARATE
    /* FDT is at end of image */
    gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
    /* Allow the early environment to override the fdt address */
    gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
                        (uintptr_t)gd->fdt_blob);

    for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
        if ((*init_fnc_ptr)() != 0) {
            hang ();
        }
    }

#ifdef CONFIG_OF_CONTROL
    /* For now, put this check after the console is ready */
    if (fdtdec_prepare_fdt()) {
        panic("** CONFIG_OF_CONTROL defined but no FDT - please see "
            "doc/README.fdt-control");
    }
#endif

#if defined(CONFIG_SYS_MEM_TOP_HIDE)
    gd->ram_size -= CONFIG_SYS_MEM_TOP_HIDE;
#endif

    addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;

#ifdef CONFIG_LOGBUFFER
#ifndef CONFIG_ALT_LB_ADDR
    /* reserve kernel log buffer */
    addr -= (LOGBUFF_RESERVE);
    debug("Reserving %dk for kernel logbuffer at %08lx\n", LOGBUFF_LEN,
        addr);
#endif
#endif

#ifdef CONFIG_PRAM
    /*
     * reserve protected RAM
     */
    reg = getenv_ulong("pram", 10, CONFIG_PRAM);
    addr -= (reg << 10);		/* size is in kB */
    debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
#endif /* CONFIG_PRAM */

#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
    /* reserve TLB table */
    gd->arch.tlb_size = 4096 * 4;
    addr -= gd->arch.tlb_size;

    /* round down to next 64 kB limit */
    addr &= ~(0x10000 - 1);

    gd->arch.tlb_addr = addr;
    debug("TLB table from %08lx to %08lx\n", addr, addr + gd->arch.tlb_size);
#endif

    /* round down to next 4 kB limit */
    addr &= ~(4096 - 1);
    debug("Top of RAM usable for U-Boot at: %08lx\n", addr);

#ifdef CONFIG_LCD
#ifdef CONFIG_FB_ADDR
    gd->fb_base = CONFIG_FB_ADDR;
#else
    /* reserve memory for LCD display (always full pages) */
    addr = lcd_setmem(addr);
    gd->fb_base = addr;
#endif /* CONFIG_FB_ADDR */
#endif /* CONFIG_LCD */

    /*
     * reserve memory for U-Boot code, data & bss
     * round down to next 4 kB limit
     */
    addr -= gd->mon_len;
    addr &= ~(4096 - 1);

    debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10, addr);

#ifndef CONFIG_SPL_BUILD
    /*
     * reserve memory for malloc() arena
     */
    addr_sp = addr - TOTAL_MALLOC_LEN;
    debug("Reserving %dk for malloc() at: %08lx\n",
            TOTAL_MALLOC_LEN >> 10, addr_sp);
    /*
     * (permanently) allocate a Board Info struct
     * and a permanent copy of the "global" data
     */
    addr_sp -= sizeof (bd_t);
    bd = (bd_t *) addr_sp;
    gd->bd = bd;
    debug("Reserving %zu Bytes for Board Info at: %08lx\n",
            sizeof (bd_t), addr_sp);

#ifdef CONFIG_MACH_TYPE
    gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
#endif

    addr_sp -= sizeof (gd_t);
    id = (gd_t *) addr_sp;
    debug("Reserving %zu Bytes for Global Data at: %08lx\n",
            sizeof (gd_t), addr_sp);

#if defined(CONFIG_OF_SEPARATE) && defined(CONFIG_OF_CONTROL)
    /*
     * If the device tree is sitting immediate above our image then we
     * must relocate it. If it is embedded in the data section, then it
     * will be relocated with other data.
     */
    if (gd->fdt_blob) {
        fdt_size = ALIGN(fdt_totalsize(gd->fdt_blob) + 0x1000, 32);

        addr_sp -= fdt_size;
        new_fdt = (void *)addr_sp;
        debug("Reserving %zu Bytes for FDT at: %08lx\n",
              fdt_size, addr_sp);
    }
#endif

    /* setup stackpointer for exeptions */
    gd->irq_sp = addr_sp;
#ifdef CONFIG_USE_IRQ
    addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
    debug("Reserving %zu Bytes for IRQ stack at: %08lx\n",
        CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);
#endif
    /* leave 3 words for abort-stack    */
    addr_sp -= 12;

    /* 8-byte alignment for ABI compliance */
    addr_sp &= ~0x07;
#else
    addr_sp += 128;	/* leave 32 words for abort-stack   */
    gd->irq_sp = addr_sp;
#endif
    interrupt_init();

    debug("New Stack Pointer is: %08lx\n", addr_sp);

#ifdef CONFIG_POST
    post_bootmode_init();
    post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

    gd->bd->bi_baudrate = gd->baudrate;
    /* Ram ist board specific, so move it to board code ... */
    dram_init_banksize();
    display_dram_config();	/* and display it */

    gd->relocaddr = addr;
    gd->start_addr_sp = addr_sp;
    gd->reloc_off = addr - _TEXT_BASE;
    debug("relocation Offset is: %08lx\n", gd->reloc_off);
    if (new_fdt) {
        memcpy(new_fdt, gd->fdt_blob, fdt_size);
        gd->fdt_blob = new_fdt;
    }
    memcpy(id, (void *)gd, sizeof(gd_t));
}
```

主要是填充 gd、bd数据，设置堆、栈。

### relocate

### board_init_r

```c
void board_init_r(gd_t *id, ulong dest_addr)
{
    ulong malloc_start;
#if !defined(CONFIG_SYS_NO_FLASH)
    ulong flash_size;
#endif

    gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
    bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

    monitor_flash_len = _end_ofs;

    enable_caches();

    board_init();	/* Setup chipselects */

#ifdef CONFIG_CLOCKS
    set_cpu_clk_info(); /* Setup clock information */
#endif
    serial_initialize();

#ifdef CONFIG_LOGBUFFER
    logbuff_init_ptrs();
#endif
#ifdef CONFIG_POST
    post_output_backlog();
#endif

    /* The Malloc area is immediately below the monitor copy in DRAM */
    malloc_start = dest_addr - TOTAL_MALLOC_LEN;

    /*初始化uboot的堆管理器*/
    mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);

#ifdef CONFIG_ARCH_EARLY_INIT_R
    arch_early_init_r();
#endif
    power_init_board();

#if !defined(CONFIG_SYS_NO_FLASH)

    flash_size = flash_init();
    if (flash_size > 0) {
# ifdef CONFIG_SYS_FLASH_CHECKSUM
        print_size(flash_size, "");

        if (getenv_yesno("flashchecksum") == 1) {
            printf("  CRC: %08X", crc32(0,
                (const unsigned char *) CONFIG_SYS_FLASH_BASE,
                flash_size));
        }
        putc('\n');
# else	/* !CONFIG_SYS_FLASH_CHECKSUM */
        print_size(flash_size, "\n");
# endif /* CONFIG_SYS_FLASH_CHECKSUM */
    } else {
        puts(failed);
        hang();
    }
#endif

#if defined(CONFIG_CMD_NAND)
    puts("NAND:  ");
    nand_init();		/* go init the NAND */
#endif

#if defined(CONFIG_CMD_ONENAND)
    onenand_init();
#endif

#ifdef CONFIG_GENERIC_MMC
    puts("MMC:   ");
    mmc_initialize(gd->bd);
#endif

#ifdef CONFIG_HAS_DATAFLASH
    AT91F_DataflashInit();
    dataflash_print_info();
#endif

    /* initialize environment */
    if (should_load_env())
        env_relocate();
    else
        set_default_env(NULL);

#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
    arm_pci_init();
#endif

    stdio_init();	/* get the devices list going. */

    /*建立一个函数跳转表*/
    jumptable_init();

#if defined(CONFIG_API)
    /* Initialize API */
    api_init();
#endif

    console_init_r();	/* fully init console as a device */

#ifdef CONFIG_DISPLAY_BOARDINFO_LATE
# ifdef CONFIG_OF_CONTROL
    /* Put this here so it appears on the LCD, now it is ready */
    display_fdt_model(gd->fdt_blob);
# else
    checkboard();
# endif
#endif

#if defined(CONFIG_ARCH_MISC_INIT)
    /* miscellaneous arch dependent initialisations */
    arch_misc_init();
#endif
#if defined(CONFIG_MISC_INIT_R)
    /* miscellaneous platform dependent initialisations */
    misc_init_r();
#endif

    /* enable exceptions */
    enable_interrupts();

    /* Initialize from environment */
    load_addr = getenv_ulong("loadaddr", 16, load_addr);

#ifdef CONFIG_BOARD_LATE_INIT
    board_late_init();
#endif

#ifdef CONFIG_BITBANGMII
    bb_miiphy_init();
#endif
#if defined(CONFIG_CMD_NET)
    puts("Net:   ");
    eth_initialize(gd->bd);
#if defined(CONFIG_RESET_PHY_R)
    reset_phy();
#endif
#endif

#ifdef CONFIG_POST
    post_run(NULL, POST_RAM | post_bootmode_get(0));
#endif

#if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
    /*
     * Export available size of memory for Linux,
     * taking into account the protected RAM at top of memory
     */
    {
        ulong pram = 0;
        uchar memsz[32];

#ifdef CONFIG_PRAM
        pram = getenv_ulong("pram", 10, CONFIG_PRAM);
#endif
#ifdef CONFIG_LOGBUFFER
#ifndef CONFIG_ALT_LB_ADDR
        /* Also take the logbuffer into account (pram is in kB) */
        pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / 1024;
#endif
#endif
        sprintf((char *)memsz, "%ldk", (gd->ram_size / 1024) - pram);
        setenv("mem", (char *)memsz);
    }
#endif

    for (;;) {
        main_loop();
    }
}
```

进行串口、flash、网卡、控制台等初始化，最后进入 main_loop()函数中。board_init()是开发板相关的初始化，在/board/samsung/xxx/xxx.c中定义。

### main_loop

main_loop()函数在common/main.c文件定义，等待终端输入命令以及对命令进行处理。

## 启动内核

### mkimage

内核编译成功会生成 vmlinux、Image、zImage，再通过 uboot 提供的工具 mkimage，执行``make uImage` 命令生成 uImage。

- **vmlinux**  原始的未经任何处理加工的原版内核 elf 文件，一般PC机上直接加载就可运行。
- **Image**  由vmlinux 经 objcopy 去掉一些不需要的东西之后得到。
- **zImage**  由Image压缩得到。
- **uImage**   uboot专用的镜像文件，它是在zImage之前加上64字节的头部信息合成，说明这个内核的版本、加载位置、生成时间、大小等信息；其0x40之后与zImage没区别。

![](/images/uboot/vmlinux.bmp)

uboot都支持uImage启动，支持zImage启动需要定义LINUX_ZIMAGE_MAGIC宏。

mkimage工具在uboot源代码的tools/目录下，用来给zImage镜像添加64字节的头部信息。
```shell
参数说明：

-A：指定 CPU 的体系结构，alpha、arm 、x86、ia64、mips、mips64、 ppc 、s390、sh、sparc 、sparc64、m68k 等；
-O：指定操作系统类型，可用值有：openbsd、netbsd、freebsd、4_4bsd、linux、 svr4、esix、solaris、irix、sco、dell、ncr、lynxos、vxworks、psos、qnx、u-boot、rtems、artos；
-T：指定镜像类型，可用值有：standalone、kernel、ramdisk、multi、firmware、script、filesystem；
-C：指定镜像压缩方式，可用值有：
    ：none 不压缩(一般使用这个，因为 zImage 是已经被 bzip2 压缩过的自解压内核)；
    ：zip 用 gzip 的压缩方式；
    ：bzip2 用 bzip2 的压缩方式；
-a：指定镜像在内存中的加载地址，镜像下载到内存中时，要按照这个地址来下载；
-e：指定镜像运行的入口点地址，这个地址就是-a 参数指定的值加上0x40（前面mkimage添加了64个字节头）；
-n：指定镜像名；
-d：指定制作镜像的源文件；
```

uboot启动内核的打印：
```shell
Booting kernel from Legacy Image at 82208000 ...
Image Name:   Linux-3.4.35
Image Type:   ARM Linux Kernel Image (uncompressed)
Data Size:    1417696 Bytes = 1.4 MiB
Load Address: 82208000
Entry Point:  82208040
Verifying Checksum ... OK
XIP Kernel Image ... OK
```

### 加载内核到DDR
uboot将内核镜像从启动介质中加载到DDR中，还要给内核传递启动参数，内核就从链接地址处开始运行。

### 校验内核格式

uboot用bootm命令引导内核，bootm会读取一个64字节的文件头，来获取这个内核镜像所针对的CPU体系结构、OS、加载到内存中的位置、在内存中入口点的位置以及镜像名等等信息。这样bootm才能为OS设置好启动环境，并跳入内核镜像的入口点。

当bootm命令执行时，uboot实际执行do_bootm()函数，在cmd_bootm.c中定义。


```c
int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
#ifdef CONFIG_NEEDS_MANUAL_RELOC
    static int relocated = 0;

    if (!relocated) {
        int i;

        /* relocate boot function table */
        for (i = 0; i < ARRAY_SIZE(boot_os); i++)
            if (boot_os[i] != NULL)
                boot_os[i] += gd->reloc_off;

        /* relocate names of sub-command table */
        for (i = 0; i < ARRAY_SIZE(cmd_bootm_sub); i++)
            cmd_bootm_sub[i].name += gd->reloc_off;

        relocated = 1;
    }
#endif

    /* determine if we have a sub command */
    argc--; argv++;
    if (argc > 0) {
        char *endp;

        simple_strtoul(argv[0], &endp, 16);
        /* endp pointing to NULL means that argv[0] was just a
         * valid number, pass it along to the normal bootm processing
         *
         * If endp is ':' or '#' assume a FIT identifier so pass
         * along for normal processing.
         *
         * Right now we assume the first arg should never be '-'
         */
        if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
            return do_bootm_subcommand(cmdtp, flag, argc, argv);
    }

    return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |
        BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
        BOOTM_STATE_LOADOS |
#if defined(CONFIG_PPC) || defined(CONFIG_MIPS)
        BOOTM_STATE_OS_CMDLINE |
#endif
        BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
        BOOTM_STATE_OS_GO, &images, 1);
}
```

## 命令体系

## uboot命令

### 变量管理

**printenv/print**  打印出系统中所有的环境变量。

**setenv/set**  设置（添加/更改）环境变量，变量名后面没参数就是删除该环境变量。

**saveenv/save**  保存环境变量的更改到flash分区。

### 内存操作

### flash操作

#### sf

```shell
sf probe [[bus:]cs] [hz] [mode]  
#init flash device on given SPI bus and chip select

sf read addr offset len    
#read `len' bytes starting at`offset' to memory at `addr'

sf write addr offset len  
#write `len' bytes from memor at `addr' to flash at `offset'

sf erase offset [+]len   
#erase `len' bytes from `offset' `+len' round up `len' to block size

sf update addr offset len  
#erase and write `len' bytes from memory at `addr' to flash at `offset'
```

### tftp

## uboot移植

## 参考

https://blog.csdn.net/qq_45544223/category_9907716.html

https://www.cnblogs.com/Cqlismy/category/1603479.html