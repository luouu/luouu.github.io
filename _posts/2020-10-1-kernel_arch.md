---
layout: post
title: linux内核架构
categories: [kernel]
description: 
keywords: 
topmost: false
---

* TOC
{:toc}

### linux系统结构

<img src="/images/kernel/kernel/linux_arch.jpeg" alt="Unix/Linux系统分层结构" style="zoom: 33%;" />

![Linux系统层次结构](/images/kernel/kernel/linux-arch.webp)

最上面是用户空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。GNU C Library （glibc）也在这里。它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。

Linux 内核可以进一步划分成 3 层。最上面是系统调用接口，它实现了一些基本的功能，例如 read 和 write。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码。这些代码是 Linux 所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。

### 内核架构

![linux内核架构](/images/kernel/kernel/kernel_struct.webp)

Linux内核的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络协议栈、进程间通信、设备驱动程序和硬件架构的相关代码。

LXR (Linux Cross Reference)也是比较流行的源代码浏览工具，它的下载及安装可参见:http://lxr.linux.no/。

**系统调用接口**

SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。

**依赖体系结构的代码**

尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。./linux/arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码在 ./linux/arch 中。

![Linux kernel map](/images/kernel/kernel/linux_kernel_map.svg)

https://makelinux.github.io/kernel/map/

## 目录详解

| 目录 / 文件名  | 源码功能简介                                                 |
| :------------- | :----------------------------------------------------------- |
| /Documentation | 说明文档，对每个目录的具体作用进行说明。                     |
| /arch          | 不同 CPU 架构下的核心代码。其中的每一个子目录都代表 Linux 支持的 CPU 架构。 |
| /block         | 块设备通用函数。                                             |
| /certs         | 与证书相关。                                                 |
| /crypto        | 常见的加密算法的C 语言实现代码，譬如 crc32、md5、sha1 等。  |
| /drivers       | 内核中所有设备的驱动程序，其中的每一个子目录对应一种设备驱动。 |
| /include       | 内核编译通用的头文件。                                       |
| /init          | 内核初始化的核心代码。                                       |
| /ipc           | 内核中进程间的通信代码。                                     |
| /kernel        | 内核的核心代码，此目录下实现了大多数 Linux 系统的内核函数。与处理器架构相关的内核代码在 /kernel/$ARCH/kernel。 |
| /lib           | 内核共用的函数库，与处理器架构相关的库在 /kernel/$ARCH/lib。 |
| /mm            | 内存管理代码，譬如页式存储管理内存的分配和释放等。与具体处理器架构相关的内存管理代码位于 /arch/$ARCH/mm 目录下。 |
| /net           | 网络通信相关代码。                                           |
| /samples       | 示例代码。                                                   |
| /scripts       | 用于内核配置的脚本文件，用于实现内核配置的图形界面。         |
| /security      | 安全性相关的代码。                                           |
| /sound         | 与音频有关的代码，包括与音频有关的驱动程序 [2]。             |
| /tools         | Linux 中的常用工具。                                         |
| /usr           | 该目录中的代码为内核尚未完全启动时执行用户空间代码提供了支持。 |
| /virt          | 此文件夹包含了虚拟化代码，它允许用户一次运行多个操作系统。   |
| COPYING        | 许可和授权信息。                                             |
| CREDITS        | 贡献者列表。                                                 |
| Kbuild         | 内核设定脚本，可以对内核中的变量进行设定。                   |
| Kconfig        | 配置哪些文件编译，那些文件不用编译 [4]。                     |
| Makefile       | 该文件将编译参数、编译所需的文件和必要的信息传给编译器。     |

### drivers

**accessibility**  这些驱动提供支持一些辅助设备。在Linux 3.9.4中，这个文件夹中只有一个驱动就是盲文设备驱动。

**acpi**  高级配置和电源接口（ACPI : Advanced Configuration and Power Interface）驱动用来管理电源使用。

**amba**  高级微控制器总线架构（AMBA : Advanced Microcontroller Bus Architecture）是与片上系统（SoC）的管理和互连的协议。SoC是一块包含许多或所有必要的计算机组件的芯片。这里的AMBA驱动让内核能够运行在这上面。

**ata**  该目录包含PATA和SATA设备的驱动程序。串行ATA（SATA）是一种连接主机总线适配器到像硬盘那样的存储器的计算机总线接口。并行ATA（PATA）用于连接存储设备，如硬盘驱动器，软盘驱动器，光盘驱动器的标准。PATA就是我们所说的IDE。

**atm**  异步通信模式(ATM : Asynchronous Transfer Mode)是一种通信标准。这里有各种接到PCI桥的驱动(他们连接到PCI总线)和以太网控制器(控制以太网通信的集成电路芯片)。

**auxdisplay**  这个文件夹提供了三个驱动。LCD 帧缓存（framebuffer）驱动、LCD控制器驱动和一个LCD驱动。这些驱动用于管理液晶显示器 —— 液晶显示器会在按压时显示波纹。注意:按压会损害屏幕,所以请不要用力戳LCD显示屏。

**base**  这是个重要的目录包含了固件、系统总线、虚拟化能力等基本的驱动。

**bcma**  这些驱动用于使用基于AMBA协议的总线。AMBA是由博通公司开发。

**block**  这些驱动提供对块设备的支持，像软驱、SCSI磁带、TCP网络块设备等等。

**bluetooth**  蓝牙是一种安全的无线个人区域网络标准(PANs)。蓝牙驱动就在这个文件夹，它允许系统使用各种蓝牙设备。例如，一个蓝牙鼠标不用电缆，并且计算机有一个电子狗(小型USB接收器)。Linux系统必须能够知道进入电子狗的信号，否则蓝牙设备无法工作。

**bus**  这个目录包含了三个驱动。一个转换ocp接口协议到scp协议。一个是设备间的互联驱动，第三个是用于处理互联中的错误处理。

**cdrom**  这个目录包含两个驱动。一个是cd-rom，包括DVD和CD的读写。第二个是gd-rom(只读GB光盘)，GD光盘是1.2GB容量的光盘，这像一个更大的CD或者更小的DVD。GD通常用于世嘉游戏机中。

**char**  字符设备驱动就在这里。字符设备每次传输数据传输一个字符。这个文件夹里的驱动包括打印机、PS3闪存驱动、东芝SMM驱动和随机数发生器驱动等。

**clk**  这些驱动用于系统时钟。

**clocksource**  这些驱动用于作为定时器的时钟。

**connector**  这些驱动使内核知道当进程fork并使用proc连接器更改UID(用户ID)、GID(组ID)和SID(会话ID)。内核需要知道什么时候进程fork(CPU中运行多个任务)并执行。否则,内核可能会低效管理资源。

**cpufreq**  这些驱动改变CPU的电源能耗。

**cpuidle**  这些驱动用来管理空闲的CPU。一些系统使用多个CPU，其中一个驱动可以让这些CPU负载相当。

**crypto**  这些驱动提供加密功能。

**dca**  直接缓存访问（DCA ： Direct Cache Access）驱动允许内核访问CPU缓存。CPU缓存就像CPU内置的RAM。CPU缓存的速度比RAM更快。然而,CPU缓存的容量比RAM小得多。CPU在这个缓存系统上存储了最重要的和执行的代码。

**devfreq**  这个驱动程序提供了一个通用的动态电压和频率调整(DVFS ： Generic Dynamic Voltage and Frequency Scaling)框架，可以根据需要改变CPU频率来节约能源。这就是所谓的CPU节能。

**dio**  数字输入/输出（DIO ：Digital Input/Output）总线驱动允许内核可以使用DIO总线。

**dma**  直接内存访问(DMA)驱动允许设备无需CPU直接访问内存。这减少了CPU的负载。

**edac**  错误检测和校正（ Error Detection And Correction）驱动帮助减少和纠正错误。

**eisa**  扩展工业标准结构总线（Extended Industry Standard Architecture）驱动提供内核对EISA总线的支持。

**extcon**  外部连接器（EXTernal CONnectors）驱动用于检测设备插入时的变化。例如，extcon会检测用户是否插入了USB驱动器。

**firewire**  这些驱动用于控制苹果制造的类似于USB的火线设备。

**firmware**  这些驱动用于和像BIOS(计算机的基本输入输出系统固件)这样的设备的固件通信。BIOS用于启动操作系统和控制硬件与设备的固件。一些BIOS允许用户超频CPU。超频是使CPU运行在一个更快的速度。CPU速度以MHz(百万赫兹)或GHz衡量。一个3.7 GHz的CPU的的速度明显快于一个700Mhz的处理器。

**gpio**  通用输入/输出(GPIO ：General Purpose Input/Output)是可由用户控制行为的芯片的管脚。这里的驱动就是控制GPIO。

**gpu**  这些驱动控制VGA、GPU和直接渲染管理(DRM ：Direct Rendering Manager )。VGA是640*480的模拟计算机显示器或是简化的分辨率标准。GPU是图形处理器。DRM是一个Unix渲染系统。

**hid**  这驱动用于对USB人机界面设备的支持。

**hsi**  这个驱动用于内核访问像Nokia N900这样的蜂窝式调制解调器。

**hv**  这个驱动用于提供Linux中的键值对(KVP ：Key Value Pair)功能。

**hwmon**  硬件监控驱动用于内核读取硬件传感器上的信息。比如，CPU上有个温度传感器。那么内核就可以追踪温度的变化并相应地调节风扇的速度。

**hwspinlock**  硬件转锁驱动允许系统同时使用两个或者更多的处理器，或使用一个处理器上的两个或更多的核心。

**i2c**  I2C驱动可以使计算机用I2C协议处理主板上的低速外设。系统管理总线(SMBus ：System Management Bus)驱动管理SMBus,这是一种用于轻量级通信的two-wire总线。

**ide**  这些驱动用来处理像CDROM和硬盘这些PATA/IDE设备。

**idle**  这个驱动用来管理Intel处理器的空闲功能。

**iio**  工业I/O核心驱动程序用来处理数模转换器或模数转换器。

**infiniband**  Infiniband是在企业数据中心和一些超级计算机中使用的一种高性能的端口。这个目录中的驱动用来支持Infiniband硬件。

**input**  这里包含了很多驱动，这些驱动都用于输入处理，包括游戏杆、鼠标、键盘、游戏端口（旧式的游戏杆接口）、遥控器、触控、耳麦按钮和许多其他的驱动。如今的操纵杆使用USB端口，但是在上世纪80、90年代，操纵杆是插在游戏端口的。

**iommu**  输入/输出内存管理单元(IOMMU ：Input/Output Memory Management Unit)驱动用来管理内存管理单元中的IOMMU。IOMMU连接DMA IO总线到内存上。IOMMU是设备在没有CPU帮助下直接访问内存的桥梁。这有助于减少处理器的负载。

**ipack**  Ipack代表的是IndustryPack。 这个驱动是一个虚拟总线,允许在载体和夹板之间操作。

**irqchip**  这些驱动程序允许硬件的中断请求(IRQ)发送到处理器，暂时挂起一个正在运行的程序而去运行一个特殊的程序（称为一个中断处理程序）。

**isdn**  这些驱动用于支持综合业务数字网(ISDN)，这是用于同步数字传输语音、视频、数据和其他网络服务使用传统电话网络的电路的通信标准。

**leds**  用于LED的驱动。

**lguest**  lguest用于管理客户机系统的中断。中断是CPU被重要任务打断的硬件或软件信号。CPU接着给硬件或软件一些处理资源。

**macintosh**  苹果设备的驱动在这个文件夹里。

**mailbox**  这个文件夹(pl320-pci)中的驱动用于管理邮箱系统的连接。

**md**  多设备驱动用于支持磁盘阵列，一种多块硬盘间共享或复制数据的系统。

**media**  媒体驱动提供了对收音机、调谐器、视频捕捉卡、DVB标准的数字电视等等的支持。驱动还提供了对不同通过USB或火线端口插入的多媒体设备的支持。

**memory**  支持内存的重要驱动。

**memstick**  这个驱动用于支持Sony记忆棒。

**message**  这些驱动用于运行LSI Fusion MPT(一种消息传递技术)固件的LSI PCI芯片/适配器。LSI大规模集成，这代表每片芯片上集成了几万晶体管、

**mfd**  多用途设备(MFD)驱动提供了对可以提供诸如电子邮件、传真、复印机、扫描仪、打印机功能的多用途设备的支持。这里的驱动还给MFD设备提供了一个通用多媒体通信端口(MCP)层。

**misc**  这个目录包含了不适合在其他目录的各种驱动。就像光线传感器驱动。

**mmc**  MMC卡驱动用于处理用于MMC标准的闪存卡。

**mtd**  内存技术设备(MTD ：Memory technology devices)驱动程序用于Linux和闪存的交互，这就就像一层闪存转换层。其他块设备和字符设备的驱动程序不会以闪存设备的操作方式来做映射。尽管USB记忆卡和SD卡是闪存设备，但它们不使用这个驱动，因为他们隐藏在系统的块设备接口后。这个驱动用于新型闪存设备的通用闪存驱动器驱动。

**net**  网络驱动提供像AppleTalk、TCP和其他的网络协议。这些驱动也提供对调制解调器、USB 2.0的网络设备、和射频设备的支持。

**nfc**  这个驱动是德州仪器的共享传输层之间的接口和NCI核心。

**ntb**  不透明的桥接驱动提供了在PCIe系统的不透明桥接。PCIe是一种高速扩展总线标准。

**nubus**  NuBus是一种32位并行计算总线。用于支持苹果设备。

**of**  此驱动程序提供设备树中创建、访问和解释程序的OF助手。

**oprofile**  这个驱动用于从驱动到用户空间进程(运行在用户态下的应用)评测整个系统。这帮助开发人员找到性能问题----性能分析机制-是用于 Linux 的若干种评测和性能监控工具中的一种

**parisc**  这些驱动用于HP生产的PA-RISC架构设备。PA-RISC是一种特殊指令集的处理器。

**parport**  并口驱动提供了Linux下的并口支持。

**pci**  这些驱动提供了PCI总线服务。

**pcmcia**  这些是笔记本的pc卡驱动

**pinctrl**  这些驱动用来处理引脚控制设备。引脚控制器可以禁用或启用I/O设备。

**platform** 这个文件夹包含了不同的计算机平台的驱动像Acer、Dell、Toshiba、IBM、Intel、Chrombooks等等。

**pnp**  即插即用驱动允许用户在插入一个像USB的设备后可以立即使用而不必手动配置设备。

**power**  电源驱动使内核可以测量电池电量，检测充电器和进行电源管理。

**pps**  Pulse-Per-Second驱动用来控制电流脉冲速率。这用于计时。

**ps3**  这是Sony的游戏控制台驱动- PlayStation3。

**ptp**  图片传输协议(PTP)驱动支持一种从数码相机中传输图片的协议。

**pwm**  脉宽调制(PWM)驱动用于控制设备的电流脉冲。主要用于控制像CPU风扇。

**rapidio**  RapidIO驱动用于管理RapidIO架构，它是一种高性能分组交换，用于电路板上交互芯片的交互技术，也用于互相使用底板的电路板。

**regulator**  校准驱动用于校准电流、温度、或其他可能系统存在的校准硬件。----用于控制系统中某些设备的电压电流供应

**remoteproc**  这些驱动用来管理远程处理器。

**rpmsg**  这个驱动用来控制支持大量驱动的远程处理器通讯总线(rpmsg)。这些总线提供消息传递设施,促进客户端驱动程序编写自己的连接协议消息。----该基础架构允许主处理器上的 Linux 操作系统管理远程处理器上远程软件环境的生命周期和通信-用于在 AMP 环境中的操作系统之间实现 IPC 的 rpmsg 组件和 API

**rtc**  实时时钟(RTC)驱动使内核可以读取时钟。

**s390**  用于31/32位的大型机架构的驱动。

**sbus**  用于管理基于SPARC的总线驱动。

**scsi**  允许内核使用SCSI标准外围设备。例如,Linux将在与SCSI硬件传输数据时使用SCSI驱动。

**sfi** 简单固件接口(SFI)驱动允许固件发送信息表给操作系统。这些表的数据称为SFI表。

**sh**  该驱动用于支持SuperHway总线。

**sn**  该驱动用于支持IOC3串口。

**spi**  这些驱动处理串行设备接口总线(SPI)，它是一个在在全双工下运行的同步串行数据链路标准,。全双工是指两个设备可以同一时间同时发送和接收信息。双工指的是双向通信。设备在主/从模式下通信(取决于设备配置)。

**ssb**  ssb(Sonics Silicon Backplane)驱动提供对在不同芯片和嵌入式设备上使用的迷你总线的支持。

**staging**  该目录含有许多子目录。这里所有的驱动还需要在加入主内核前经过更多的开发工作。

**target**  SCSI设备驱动

**tc**  这些驱动用于TURBOchannel，TURBOchannel是数字设备公司开发的32位开放总线。这主要用于DEC工作站。

**thermal**  thermal驱动使CPU保持较低温度。---Linux温控框架

**tty**  tty驱动用于管理物理终端连接。

**uio**  该驱动允许用户编译运行在用户空间而不是内核空间的驱动。这使用户驱动不会导致内核崩溃。-----运行在用户空间的IO技术

**usb**  USB设备允许内核使用USB端口。闪存驱动和记忆卡已经包含了固件和控制器,所以这些驱动程序允许内核使用USB接口和与USB设备。

**uwb**  Ultra-WideBand驱动用来管理短距离，高带宽通信的超低功耗的射频设备

**vfio**  允许设备访问用户空间的VFIO驱动。用户态驱动框架。

**vhost**  这是用于宿主内核中的virtio服务器驱动。用于虚拟化中。

**video**  这是用来管理显卡和监视器的视频驱动。

**virt**  这些驱动用来虚拟化。

**virtio**  这个驱动用来在虚拟PCI设备上使用virtio设备。用于虚拟化中。

**vlynq**  这个驱动控制着由德州仪器开发的专有接口。这些都是宽带产品，像WLAN和调制解调器，VOIP处理器，音频和数字媒体信号处理芯片。

**vme**  WMEbus最初是为摩托罗拉68000系列处理器开发的总线标准

**w1**  这些驱动用来控制one-wire总线。

**watchdog**  该驱动管理看门狗定时器，这是一个可以用来检测和恢复异常的定时器。

**xen**  该驱动是Xen管理程序系统。这是个允许用户运行多个操作系统在一台计算机的软件或硬件。这意味着xen的代码将允许用户在同一时间的一台计算机上运行两个或更多的Linux系统。用户也可以在Linux上运行Windows、Solaris、FreeBSD、或其他操作系统。

**zorro**  该驱动提供Zorro Amiga总线支持。

Documentation/CodingStyle 文件描 述 了 Linux 内 核 对 编 码 风 格 的 要 求，内 核 下 的scripts/checkpatch.pl 脚本可以检查代码风格。

## 进程管理

### 进程控制

在设备驱动编程中，当请求的资源不能得到满足时，驱动一般会调度其他进程执行，并使本进程进入睡眠状态，直到它请求的资源被释放，才会被唤醒而进入就绪态。睡眠分成可被打断的睡眠和不可被打断的睡眠，两者的区别在于可被打断的睡眠在收到信号的时候会醒。

进程是操作系统进行资源管理的最小单位，进程需要管理打开的文件、挂起的信号、内核内部数据、处理器状态等。线程是操作系统进行调度的最小单位。

在linux中，线程和进程都使用 struct task_struct 结构体表示。task_struct的state域存储了进程当前的状态，总共有7种状态：

* **TASK_RUNNING** 一般指就绪状态，进程正在运行。

* **TASK_INTERRUPTIBLE** 进程暂停，直到它获得满足它继续运行的条件，比如进程获得了需要的资源、接收到硬件终端、或者收到某些signal等。

* **TASK_UNINTERRUPTIBLE** 进程暂停，不会被signal唤醒，只能等待某些事件(资源、硬件终端等)。
* **TASK_STOPPED** 进程中止运行，进程在接收到SIGSTOP, SIGTSTP, SIGTTIN或者SIGTTOU 信号时会进入这个状态。 接收到SIGCONT信号后，重新回到进行状态。

* **TASK_TRACED** 进程处于被调试，例如通过ptrace()对程序进行调试。

* **EXIT_ZOMBIE** 进程将要结束，等待父进程调用wait4()或者waitpid()来回收该进程。

* **EXIT_DEAD** 进程退出，这个状态主要用于避免多个进程同时对该进程调用类似wait()的函数或者系统调用。

![proc](/images/kernel/kernel/proc.png)

每个进程都有两个栈，用户栈和内核栈，在用户态运行时CPU堆栈指针寄存器指向用户栈地址。进程在内核态运行时，CPU堆栈指针寄存器指向内核栈地址。内核栈使用的空间很小，通常为8KB。
![内核栈](/images/kernel/kernel/task_struct.png)

内核通过唯一的进程标识值PID来标识每个进程，用全局指针current指向当前正在运行的进程的 task_struct。

设备驱动中，如果需要几个并发执行的任务，可以启动内核线程，函数为:

```c
pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
```

### 进程调度

在支持内核抢占的系统中，更高优先级的进程可以抢占低优先级进程。但在中断处理函数中，中断上下文的底半部，进程持有自旋锁的情况下不允许内核抢占。

内核可以使用schedule()函数主动调试进程。

 ```c
current->state=TASK_INTERRUPTIBLE;
schedule(); 
 ```

## 内存管理

![mmu](/images/kernel/kernel/mmu.png)

MMU 具有虚拟地址和物理地址转换、内存访问权限保护等功能，这将使得操作系统能单独为系统的每个用户进程分配独立的内存空间并保证用户空间不能访问内核空间的地址。内存管理的源码在/mm 中。

**逻辑地址**是由程式产生的和段相关的偏移地址部分。机器语言指令中出现的内存地址，都是逻辑地址。编译器编译程序时，会为程序生成代码段和数据段，然后将所有代码放到代码段中，将所有数据放到数据段中。最后程序中的每句代码和每条数据都会有自己的逻辑地址。

**线性地址**是逻辑地址到物理地址变换之间的中间层。程式代码会产生逻辑地址，也就是段中的偏移地址，加上段基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再变换成物理地址。

CPU加载程序后，会为程序分配代码段内存和数据段内存，代码段内存的基址保存在CS中，数据段内存的基址保存在DS中。

**物理地址**是CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果没有启用分页机制，物理地址等于线性地址。

CPU要将一个逻辑地址转换为物理地址，需要两步：首先利用段式内存管理单元将逻辑地址转换成线性地址，再利用页式内存管理单元，把线性地址转换为物理地址。

### 段式管理

因为intel的CPU有20位的地址总线，而寄存器16位，要寻址2^20^=1M的内存空间，只能采用分段管理。线性地址 = 段基址 * 16 + 逻辑地址

### 页式管理

CPU的页式内存管理单元负责把线性地址转换为物理地址。从管理和效率的角度出发，线性地址被分为固定长度单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，用4KB为一个页来划分，整个线性地址就被划分为共有2^20^个页的数组，我们称之为页目录。目录中的每一个目录项，就是对应的页的地址。这个数组有2^20^个成员，每个成员是一个地址（32位机，一个地址4字节），那么要表示这个数组，就要4MB的内存空间。为了节省空间，引入二级管理模式来组织分页单元。

![img](/images/kernel/kernel/mmu_page.jpg)

**每个进程都有其独立的虚似内存，拥有惟一的页目录和页表**，它的地址放在CPU的cr3寄存器中，是进行地址转换的开始点。每一个32位的线性地址被划分为三部分：页目录索引(10位)、页表索引(10位)、偏移(12位) 。依据以下步骤进行转换：

1. 从cr3中取出进程的页目录地址。

2. 根据线性地址的页目录索引，找到页表地址。

3. 根据线性地址的页表索引，在页表中找到页的起始地址。

4. 将页的起始地址与线性地址中的偏移相加。

在二级管理模式中，页目录共有2^10^项，每项有2^10^个页表，每个页中可寻址2^12^个字节，2^10^ * 2^10^ * 2^12^ = 2^32^ = 4GB。能够表示4G的地址。同时页目录项和页表项共占空间 (2^10 * 4 + 2 ^10 *4) = 8KB，节省了空间。

* **Linux的页式内存管理**

有些CPU，还有三级，甚至四级架构，Linux为了在更高层次提供抽像，为每个CPU提供统一的界面。提供了一个四层页管理架构，来兼容这些二级、三级、四级管理架构的CPU。这四级分别为： 页全局目录PGD、页上级目录PUD、页中间目录PMD、页表PT。 整个转换依据硬件转换原理，多了二次数组的索引。

![img](/images/kernel/kernel/mmu_page2.jpg)

逻辑地址、线性地址和物理地址之间的变换过程如下图所示：

![虚拟地址、线性地址和物理地址的转换](/images/kernel/kernel/mem_t.jpg)

### 虚拟内存

* **内核空间和用户空间**

Linux采用虚拟内存管理技术，使得每个进程都有独立的进程地址空间，Linux将4GB的虚拟内存空间分成两个部分：0 ~ 3GB属于用户空间，3 ~ 4GB 属于内核空间。用户进程只能访问用户空间，只能通过系统调用访问内核空间。

![img](/images/kernel/kernel/user_space.png)

用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。

内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。

进程 fork(),execve(),malloc()等操作分配的内存仅仅是虚拟内存。只有当进程真正去访问地址时，才会产生缺页异常，内核才会为进程分配物理页，并建立对应的页表。

### 内核空间

ARM处理器分为7种工作模式:

* 用户模式(usr)：大多数的应用程序运行在用户模式下,当处理器运行在用户模式下时,某些被保护的系统资源是不能被访问的。
* 快速中断模式(fiq)：用于高速数据传输或通道处理。
* 外部中断模式(irq)：用于通用的中断处理。
* 管理模式(svc)：操作系统使用的保护模式。
* 数据访问终止模式(abt)：当数据或指令预取终止时进入该模式,可用于虚拟存储及存储保护。
* 系统模式(sys)：运行具有特权的操作系统任务。
* 未定义指令中止模式(und)：当未定义的指令执行时进入该模式,可用于支持硬件协处理器的软件仿真。

Linux为了保护内核的安全，只使用处理器的2个模式，把系统分成了2部分。内核可进行任何操作，特权指令只能在内核态使用，从而起到保护作用。而应用程序则被禁止对硬件的直接访问和对内存的未授权访问。内核空间和用户空间使用不同的地址空间。用户空间只能通过系统调用和硬件中断转移到内核空间。

Linux 中 1GB 的内核地址空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区、专用页面映射区和系统保留映射区这几个区域。

物理内存映射区是从3G开始最896MB的线性空间，物理内存顺序映射在这个区域中，虚拟地址 = 3G + 物理地址。

动态内存映射区由vmalloc()分配，其线性空间连续，但物理空间不一定连续，可能处于低端内存，也可能处于高端内存。

超过直接映射区896MB的那部分内存称为高端内存，内核在存取高端内存时必须将它们映射到高端页面映射区。内核空间最顶部 FIXADDR_TOP~4GB 的区域作为保留区。

内核空间与用户空间的内存不能直接互访，必需借助函数 `copy_from_user()`完成用户空间到内核空间的拷贝，以及`copy_to_user()`完成内核空间到用户空间的拷贝。如果要复制的内存是简单类型，如char、int、long等，则可以使用`put_user()`和`get_user()`。宏__user 是一个指向用户空间地址的指针。

```c
# define __user  __attribute__((noderef, address_space(1)))

long copy_from_user(void *to, const void __user *from, unsigned long n);
long copy_to_user(void __user *to, const void *from, unsigned long n);

put_user(val, void __user *ptr); /* 内核→用户 */
get_user(val, void __user *ptr); /* 用户→内核 */
```

## 虚拟文件系统

虚拟文件系统(VFS)隐藏各种了硬件的具体细节，为所有的设备提供了统一的接口。而且它独立于各个具体的文件系统，是对各种文件系统的一个抽象，它使用超级块super block 存放文件系统相关信息，使用索引节点inode存放文件的物理信息，使用目录项dentry存放文件的逻辑信息。文件系统的源代码在 ./linux/fs 中。

![img](/images/kernel/kernel/VFS.webp)

​    在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。文件系统层之下是缓冲区缓存，这个缓存层通过将数据保留一段时间。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。

## 网络协议栈

网络协议栈提供了对各种网络标准的存取和各种网络硬件的支持。网络协议栈可分为网络协议和网络驱动程序，网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备通信。内核中网络源码在 ./linux/net 中。

## 进程通信

进程通信(IPC)支持进程之间的通信，包含信号量、共享内存、管道等,这些机制可协助多个进程、多资源的互斥访问、进程间的同步和消息传递。

## 性能

![linux_performance_tools](/images/kernel/kernel/linux_performance_tools.jpg)
