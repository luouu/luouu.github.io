<!--
 * @Description: 
 * @Author: luo_u
 * @Date: 2020-05-18 11:49:24
 * @LastEditTime: 2020-08-24 17:50:42
--> 
# shell

unset 命令用于取消变量或取消变量赋值。

`$?` 可以来检查前一命令的结束状态。如果是 0，说明前一个命令执行成功，否则执行失败。

反引号将命令括起来执行。格式：\`pwd\`，可以得到这个命令的返回值。

将标准输出和错误输出同时重定向：
>ls /usr/share/doc > out.txt 2>&1

>ls /usr/share/doc &> out.txt




## 分支
```shell
if [表达式]; then 
    ...
else 
    ...
fi 
```

- **整数比较**
```
-eq 等于，如: if [ "$a" -eq "$b" ]   
-ne 不等于，如: if [ "$a" -ne "$b" ]   
-gt 大于，如: if [ "$a" -gt "$b" ]   
-ge 大于等于，如: if [ "$a" -ge "$b" ]   
-lt 小于，如: if [ "$a" -lt "$b" ]   
-le 小于等于，如: if [ "$a" -le "$b" ]   
<   小于(需要双括号)，如: (("$a" < "$b"))   
<=  小于等于(需要双括号)，如: (("$a" <= "$b"))   
>   大于(需要双括号)，如: (("$a" > "$b"))   
>=  大于等于(需要双括号)，如: (("$a" >= "$b"))   
```

- **字符串比较**
```
= 等于，如: if [ "$a" = "$b" ]   
== 等于，如: if [ "$a" == "$b" ]，与=等价 
!=　不等于，if [ "$a" != "$b" ]
<　小于，如：
　 if [[ "$a" < "$b" ]]
　 if [ "$a" \< "$b" ]         #在[]结构中需要对<进行转义
>　大于，如：
　 if [[ "$a" > "$b" ]]
　 if [ "$a" \> "$b" ]         #在[]结构中需要对>进行转义
-z　字符串为null，即长度为0
-n　字符串不为null，即长度不为0
```



**比较两个字符串是否相等的办法**
>if [ "$test"x = "test"x ]; then

这里的关键有几点：
1. 使用单个等号，等号两边各有一个空格。
2. 注意到"\$test"x最后的x，这是特意安排的，因为当$test为空的时候，上面的表达式就变成了x = testx，显然是不相等的。而如果没有这个x，表达式就会报错：[: =: unary operator expected。



**==的功能在`[[]]`和`[]`中的行为是不同的**
- [[ \$a == z* ]]   # 如果$a以"z"开头(模式匹配)那么将为true   
- [[ \$a == "z*" ]] # 如果$a等于z*(字符匹配),那么结果为true   
- [ \$a == z* ] # File globbing 和word splitting将会发生
- [ "\$a" == "z" ] # 如果$a等于z(字符匹配),那么结果为true





### sh
shell命令解释器
```shell
bash [options] [file]

-c string  命令从-c后的字符串读取。
-i  实现脚本交互。
-n  进行shell脚本的语法检查。
-x  跟踪脚本调试shell脚本，能打印出所执行的每一行命令以及当前状态。
```

### test 
用来测试文件。
```shell
-d  如果文件存在并且是目录，返回true
-e  如果文件存在，返回true
-f  如果文件存在并且是普通文件，返回true
-r  如果文件存在并可读，返回true
-s  如果文件存在并且不为空，返回true
-w  如果文件存在并可写，返回true
-x  如果文件存在并可执行，返回true
```




